


################################################################################
## Setup                                                                      ##
################################################################################

# Set seed
set.seed(3724)

# Kernel width and Gaussian process variance
kw0=5000
vu0=1e7

# Include legend on plots or not; inclusion can obscure plot elements on small figures
inc_legend=FALSE

# Suppose we have population size and cost-per-sample without a risk score as follows
N=100000
k1=0.4

# Suppose that true values of a,b,c are given by
theta_true=c(10000,1.2,0.2)
theta_lower=c(1,0.5,0.1) # lower bounds for estimating theta
theta_upper=c(20000,2,0.5) # upper bounds for estimating theta

# We will estimate the posterior at these values of n
n=seq(1000,N,length=100)

# Set to TRUE to use Bayesian emulation, FALSE to directly try and minimise error in OHS
use_em=TRUE

# Simulation sizes
n_iter=50 # Add up to this many points
nx=100 # Resample this many times to estimate error.

# Specification correct
spec=TRUE



################################################################################
## Initialisation                                                             ##
################################################################################

## True mean cost function
if (spec==TRUE) {
  # Mean cost follows a power-law form
  true_mean=function(n) powerlaw_mean_fn(n,theta_true)
} else {
  # Mean cost follows a double-descent form
  true_mean=function(n) powerlaw_mean_fn(n,theta_true) + (2e4)*dnorm(n,mean=4e4,sd=8e3)
}
# e.g.:
# nn=nn=seq(1000,N,length=200)
# true_mean=function(n) powerlaw_mean_fn(n,theta_true) + (2e4)*dnorm(n,mean=4e4,sd=8e3)
# plot(nn,powerlaw_mean_fn(nn,theta_true),type="l")
# lines(nn,powerlaw_mean_fn(nn,theta_true) + (2e4)*dnorm(nn,mean=4e4,sd=8e3),col="red")


# We start with nstart random holdout set sizes (nset0),
#  with corresponding cost-per-individual estimates d0 derived
#  with various errors var_w0
nstart=5
vwmin=0.001; vwmax=0.02
nset0=round(runif(nstart,1000,N/2))
var_w0=runif(nstart,vwmin,vwmax)
d0=rnorm(nstart,mean=true_mean(nset0),sd=sqrt(var_w0))

# We estimate theta from these three points
theta0=powersolve(nset0,d0,y_var=var_w0,lower=theta_lower,upper=theta_upper,init=theta_true,control=list(parscale=theta_true))$par

# True optimal holdout size
nn=10:100000
ohs_true=nn[which.min(k1*nn + true_mean(nn)*(N-nn))]





################################################################################
## Functions                                                                  ##
################################################################################


ntri=function(nset,var_w,nx=100,method="MLE") {
  out=rep(0,nx)
  for (i in 1:nx) {
    d1=rnorm(length(nset),mean=true_mean(nset),sd=sqrt(var_w0))
    theta1=powersolve(nset,d1,y_var=var_w,lower=theta_lower,upper=theta_upper,init=theta_true,control=list(parscale=theta_true))$par
    if (method=="MLE") {
      out[i]=optimal_holdout_size(N,k1,theta1)$size
    } else {
      nn=seq(1000,N,length=1000)
      p_mu=mu_fn(nn,nset=nset,d=d1,var_w = var_w, N=N,k1=k1,theta=theta1,k_width=kw0,var_u=vu0)
      out[i]=nn[which.min(p_mu)]
    }
  }
  return(out)
}



################################################################################
## Iteratively generate lists of points and estimate OHS                      ##
################################################################################

# Point set nsetr generated by adding random n values, nsete generated by
#  adding values suggested by Bayesian emulator, and nsetf generated by
#  minimising error after adding point.
nsetr=nset0; dr=d0; var_wr=var_w0; theta_r=theta0
nsete=nset0; de=d0; var_we=var_w0; theta_e=theta0
nsetf=nset0; df=d0; var_wf=var_w0; theta_f=theta0

# Initialise matrices of records
ohs_e=matrix(0,n_iter,nx)
ohs_e[1,]=ntri(nset,var_w,nx)

ohs_r=matrix(0,n_iter,nx)
ohs_r[1,]=ntri(nset,var_w,nx)

ohs_f=matrix(0,n_iter,nx)
ohs_f[1,]=ntri(nset,var_w,nx)

for (i in 2:n_iter) {

  # Add next point to nsetr (randomly)
  n_newr=round(runif(1,1000,N))
  var_wr_new=runif(1,vwmin,vwmax)
  dr_new=rnorm(1,mean=true_mean(n_newr),sd=sqrt(var_wr_new))
  nsetr=c(nsetr,n_newr); var_wr=c(var_wr,var_wr_new); dr=c(dr,dr_new)
  theta_r=powersolve(nsetr,dr,y_var=var_wr,lower=theta_lower,upper=theta_upper,init=theta_true,control=list(parscale=theta_true))$par

  # Add next point to nsete (Bayesian emulation)
  exp_imp_em = exp_imp_fn(n,nset=nsete,d=de,var_w = var_we, N=N,k1=k1,theta=theta_e,k_width=kw0,var_u=vu0)
  n_newe=n[which.max(exp_imp_em)]
  var_we_new=runif(1,vwmin,vwmax)
  de_new=rnorm(1,mean=true_mean(n_newe),sd=sqrt(var_we_new))
  nsete=c(nsete,n_newe); var_we=c(var_we,var_we_new); de=c(de,de_new)
  theta_e=powersolve(nsete,de,y_var=var_we,lower=theta_lower,upper=theta_upper,init=theta_true,control=list(parscale=theta_true))$par

  # Add next point to nsetf (direct reduction of variance)
  exp_imp_em = nextpoint(n,nset=nsetf,d=df,var_w = var_wf, N=N,k1=k1,nmed=10,lower=theta_lower,upper=theta_upper,init=theta_true)
  n_newf=n[which.min(exp_imp_em)]
  var_wf_new=runif(1,vwmin,vwmax)
  df_new=rnorm(1,mean=true_mean(n_newf),sd=sqrt(var_wf_new))
  nsetf=c(nsetf,n_newf); var_wf=c(var_wf,var_wf_new); df=c(df,df_new)
  theta_f=powersolve(nsetf,df,y_var=var_wf,lower=theta_lower,upper=theta_upper,init=theta_true,control=list(parscale=theta_true))$par


  ohs_r[i,]=ntri(nsetr,var_wr,nx,method="MLE")
  ohs_e[i,]=ntri(nsete,var_we,nx,method="GP")
  ohs_f[i,]=ntri(nsetf,var_wf,nx,method="MLE")

  print(i)
}




################################################################################
## Draw figure                                                                ##
################################################################################

#load("~/Desktop/bayes_vs_rand_specTRUE.RData")
#load("~/Desktop/bayes_vs_rand.RData")


alpha=0.1;
dd=4 # horizontal line spacing
ymax=80000
n_iter=dim(ohs_e)[1]
plot(0,xlim=c(0,n_iter),ylim=c(0,ymax),type="n",
  xlab="Training set size",ylab="OHS and error")
abline(h=ohs_true,col="blue",lty=2)
points(1:n_iter,rowMedians(ohs_r),pch=16,cex=0.5)
segments(
  1:n_iter,apply(ohs_r,1,function(x) pmax(0,quantile(x,alpha/2))),
  1:n_iter,apply(ohs_r,1,function(x) pmin(ymax,quantile(x,1-alpha/2))),
  col="black"
)
points(1:n_iter + 1/dd,rowMedians(ohs_e),pch=16,cex=0.5,col="red")
segments(
  1:n_iter + 1/dd,apply(ohs_e,1,function(x) pmax(0,quantile(x,alpha/2))),
  1:n_iter + 1/dd,apply(ohs_e,1,function(x) pmin(ymax,quantile(x,1-alpha/2))),
  col="red"
)
points(1:n_iter + 2/dd,rowMedians(ohs_f),pch=16,cex=0.5,col="blue")
segments(
  1:n_iter + 2/dd,apply(ohs_f,1,function(x) pmax(0,quantile(x,alpha/2))),
  1:n_iter + 2/dd,apply(ohs_f,1,function(x) pmin(ymax,quantile(x,1-alpha/2))),
  col="blue"
)

